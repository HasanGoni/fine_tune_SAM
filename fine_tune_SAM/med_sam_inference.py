# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/05_inference_with_medSAM.ipynb.

# %% auto 0
__all__ = ['get_bounding_box', 'get_prediction']

# %% ../nbs/05_inference_with_medSAM.ipynb 8
import torch
from typing import List, Dict, Any, Union, Tuple
from transformers import SamModel, SamProcessor
import numpy as np
from PIL import Image

# %% ../nbs/05_inference_with_medSAM.ipynb 9
#from cv_tools.core import *

# %% ../nbs/05_inference_with_medSAM.ipynb 11
def get_bounding_box(
    ground_truth_map:np.ndarray
    ):
  ' Get bounding box from mask'
  # get bounding box from mask
  y_indices, x_indices = np.where(ground_truth_map > 0)
  x_min, x_max = np.min(x_indices), np.max(x_indices)
  y_min, y_max = np.min(y_indices), np.max(y_indices)
  # add perturbation to bounding box coordinates
  H, W = ground_truth_map.shape
  x_min = max(0, x_min - np.random.randint(0, 20))
  x_max = min(W, x_max + np.random.randint(0, 20))
  y_min = max(0, y_min - np.random.randint(0, 20))
  y_max = min(H, y_max + np.random.randint(0, 20))
  bbox = [x_min, y_min, x_max, y_max]

  return bbox

# %% ../nbs/05_inference_with_medSAM.ipynb 12
def get_prediction(
        model:SamModel,
        model_name:str, # checkpoint in hugggingface
        image:Image.Image,
        boxes:List[int],
        device:Union[str, None] = None,
        threshold:float = 0.5
    ) -> Tuple[np.ndarray, np.ndarray]:

    device = device if device else 'cuda' if torch.cuda.is_available() else 'cpu'
    processor = SamProcessor.from_pretrained(model_name)
    model.to(device)


    inputs = processor(
        image,
        input_boxes=[boxes],
        return_tensors="pt",

    )
    model.to(device)
    with torch.no_grad():
        outputs = model(**inputs, multimask_output=False)
    preds = torch.sigmoid(outputs.pred_masks.squeeze(1))
    preds = preds.cpu().numpy().squeeze()
    return (preds >= threshold).astype(np.uint8)




